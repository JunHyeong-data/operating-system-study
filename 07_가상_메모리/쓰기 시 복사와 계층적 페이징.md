# 📘 추가 강의: 쓰기 시 복사(Copy-on-Write)와 계층적 페이징(Hierarchical Paging)

이번 추가 강의에서는 **페이징이 제공하는 추가적인 이점** 중 다음 두 가지 개념을 소개합니다:

1. 쓰기 시 복사(Copy-on-Write)
2. 계층적 페이징(Hierarchical Paging)

---

## ✍️ 1. 쓰기 시 복사 (Copy-on-Write)

### 🔸 개요
- **포크(Fork)** 시스템 호출은 부모 프로세스와 동일한 자식 프로세스를 생성합니다.
- 전통적으로는 부모 프로세스의 **모든 메모리 페이지**를 자식에게 **복사**하여 별도로 할당했습니다.
- 하지만 이는 **중복된 메모리 낭비**와 **복사 시간 증가**라는 문제를 야기합니다.

### 🔸 Copy-on-Write 방식
- **초기에는 부모와 자식 프로세스가 동일한 페이지(프레임)를 공유**합니다.
- 단, **읽기만 가능**하게 접근 허용됩니다.
- 둘 중 **하나라도 쓰기 작업을 수행하면**, 해당 페이지가 **복사되어 새 프레임에 할당**됩니다.

### 📌 예시 흐름
1. 부모와 자식 프로세스가 동일한 프레임을 공유함.
2. 자식이 **페이지 2번에 쓰기 작업**을 수행함.
3. 페이지 2번의 **복사본이 새로운 프레임에 생성됨**.
4. 이후 자식 프로세스는 복사된 페이지를 참조하게 됨.

### ✅ 장점
- **불필요한 복사 방지**로 메모리 절약
- **효율적인 자원 공유** 가능
- 자식이 쓰기를 하지 않으면 **복사 자체가 발생하지 않음**

---

## 🧱 2. 계층적 페이징 (Hierarchical Paging)

### 🔸 문제점
- 페이지 테이블 크기는 **프로세스 크기에 비례하여 증가**함.
- 큰 페이지 테이블을 **전부 메모리에 유지하면 낭비** 발생.

### 🔸 해결 방법: 계층적 페이징
- **페이지 테이블 자체를 다시 페이징**하여 다단계로 구성.
- **Outer Page Table(최상위)**가 하위 페이지 테이블들을 참조.
- CPU는 **최상단 테이블만 메모리에 상시 유지**, 하위 테이블은 필요 시에만 메모리에 로딩.

### 🔸 예시 (2단계 페이징 기준)

#### 논리 주소 구성
- `p1`: 최상위(outer) 페이지 테이블의 인덱스
- `p2`: 하위 페이지 테이블의 인덱스
- `offset`: 해당 페이지 내의 변위

#### 주소 변환 과정
1. `p1` → Outer Page Table에서 해당 하위 페이지 테이블 주소 찾기
2. `p2` → 해당 하위 테이블에서 페이지가 매핑된 프레임 번호 획득
3. `offset`을 더해 최종 물리 주소 도출

### ✅ 장점
- **필요한 페이지만 메모리에 유지**
- 메모리 사용 효율 증가

### ⚠️ 유의점
- 계층이 많아질수록 **메모리 참조 횟수 증가**
- **페이지 폴트**가 발생하면 더 많은 메모리 접근이 필요

---

## 🧾 정리

| 개념            | 설명 |
|-----------------|------|
| Copy-on-Write   | 쓰기 전까지 부모/자식이 페이지 공유. 쓰기 발생 시 복사본 생성 |
| 계층적 페이징   | 페이지 테이블을 여러 단계로 나눠 필요한 부분만 메모리에 적재 |
| Outer Page Table | 최상위 테이블. 항상 메모리에 유지되어야 함 |
| 페이지 폴트     | 참조하려는 페이지가 메모리에 없는 경우. 계층이 깊을수록 비용 증가 |

---

> 📌 참고: 계층적 페이징은 **2단계**, **3단계**, **4단계** 등으로 더 확장 가능하지만,  
> 계층이 깊을수록 **속도 저하**의 가능성도 커짐.
